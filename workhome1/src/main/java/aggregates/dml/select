-- Count the number of facilities
 >> select count (*) from cd.facilities

-- Count the number of expensive facilities
 >> select count (*) from cd.facilities
    where guestcost >= 10

-- Count the number of recommendations each member makes
 >> select recommendedby, count(*) from cd.members
    where recommendedby is not null
    group by recommendedby
    order by recommendedby

-- List the total slots booked per facility
 >> select facid , sum (slots) from cd.bookings
    group by facid
    order by facid

-- List the total slots booked per facility in a given month
 >> select facid , sum(slots) as Total  from cd.bookings
    where starttime >= '2012-09-01' and starttime < '2012-10-01'
    group by facid
    order by sum (slots)

-- List the total slots booked per facility per month
 >> select facid , extract(month from starttime)as month ,sum(slots)  from cd.bookings
    where extract(year from starttime) = '2012'
    group by facid, month

--Find the count of members who have made at least one booking
 >> select count(*) from
    (select distinct memid from cd.bookings) as mems

--List facilities with more than 1000 slots booked
 >> select facid , sum (slots) from cd.bookings
    group by facid
    having sum (slots) > 1000
    order by facid

--Find the total revenue of each facility
 >> select name , sum (case
    when m.memid = 0 then b.slots * guestcost
    else b.slots * membercost
    end ) as revenue
    from cd.facilities f
    join cd.bookings b on b.facid = f.facid
    join cd.members m on m.memid = b.memid
    group by name
    order by revenue

--Find facilities with a total revenue less than 1000
 >> select name , sum (case
    when m.memid = 0 then b.slots * guestcost
    else b.slots * membercost
    end ) as revenue
    from cd.facilities f
    join cd.bookings b on b.facid = f.facid
    join cd.members m on m.memid = b.memid
    group by name
    having revenue < 1000
    order by revenue


--Output the facility id that has the highest number of slots booked
 >> select book.facid , max(max1) as m from
    (select facid, sum(slots) as "max1" from cd.bookings
    group by facid) as book
    group by book.facid
    having max (max1) = (select  max(book2.max2) as m2 from
    (select sum(slots) as "max2" from cd.bookings
    group by facid) as book2)

--List the total slots booked per facility per month, part 2
 >> select b.facid , extract(month from starttime)as month , sum(slots)as sum1 from  cd.bookings b
    join cd.facilities f  on b.facid = f.facid
    where extract (year from starttime) = '2012'
    group by b.facid,month

    union all

    select facid , null as month , sum (sum1) from (select b.facid , extract(month from starttime) as month , sum(slots) as sum1 from  cd.bookings b
    join cd.facilities f  on b.facid = f.facid
    where extract (year from starttime) = '2012'
    group by b.facid,month) as foo
    group by facid

    union all

    select null , null , sum(sum1) from (select b.facid, extract(month from starttime) as month, sum(slots) as sum1 from  cd.bookings b
    join cd.facilities f  on b.facid = f.facid
    where extract (year from starttime) = '2012' group by b.facid,month) as foo
    order by facid,month

--List the total hours booked per named facility
 >> select facs.facid , facs.name, round (sum(bks.slots)/2.0,2)as "Total Hours" from cd.bookings bks
    inner join cd.facilities facs on facs.facid = bks.facid
    group by facs.facid, facs.name
    order by facs.facid;

--List each member's first booking after September 1st 2012
 >> select surname , firstname , b.memid , min(starttime) as starttime from cd.bookings b
    join cd.members m on m.memid = b.memid
    where  starttime >= '2012-09-01'
    group by surname ,firstname , b.memid
    order by b.memid

--Produce a list of member names, with each row containing the total member count
 >> select (select count(*) from cd.members) as count , firstname , surname from cd.members
    order by joindate

--Produce a numbered list of members
 >> select  row_number()over() , firstname , surname from cd.members

--Output the facility id that has the highest number of slots booked, again
 >> select  f.facid ,max(s) as m from
    (select facid, sum(slots) as s from cd.bookings
    group by facid) as f
    group by f.facid
    having max(s) = (select max(s) as m from
    (select facid, sum(slots) as s from cd.bookings
    group by facid) as f )

--Rank members by (rounded) hours used
 >> select firstname , surname , (sum(slots) +10)/20 *10 as hours , rank() over(order by (sum(slots) +10)/20 *10 desc) from cd.members m
    join cd.bookings b on b.memid = m.memid
    group by firstname,	surname
    order by rank, surname, firstname;

--Find the top three revenue generating facilities
 >> select name , rank()over(order by sum desc) as rank from (select name , sum (cost) as sum from
    (select name, case
    when memid = 0 then slots * guestcost
    else slots * membercost
    end as cost
    from cd.bookings b  join cd.facilities f on b.facid = f.facid) as fr
    group by name
    order by sum desc) as f1
    limit 3

--Classify facilities by value
 >> select name , case when s = 1 then 'high'
    when s = 2 then  'average'
    else   'low'
    end  revenue
    from (select name, ntile (3)over(order by sum(case
    when memid = 0 then slots * f.guestcost
    else slots * membercost
    end ) desc) as s from cd.facilities f
    join cd.bookings b on f.facid = b.facid
    group by name) as f1
    order by s, name;


--Calculate the payback time for each facility
 >> select name , f.initialoutlay/
    ((sum (case when memid = 0 then slots * f.guestcost
    else slots * membercost
    end )/3) - monthlymaintenance) as i
    from cd.bookings b
    join cd.facilities f on b.facid = f.facid
    group by f.facid
    order by name;


--Calculate a rolling average of total revenue
 >> select 	dategen.date ,
    (select sum(case
    when memid = 0 then slots * facs.guestcost
    else slots * membercost
    end) as rev
    from cd.bookings bks
    inner join cd.facilities facs
    on bks.facid = facs.facid
    where bks.starttime > dategen.date - interval '14 days'
    and bks.starttime < dategen.date + interval '1 day')/15 as revenue
    from
    (select cast(generate_series(timestamp '2012-08-01',
    '2012-08-31','1 day') as date) as date)  as dategen
    order by dategen.date;
